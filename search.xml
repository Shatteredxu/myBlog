<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2017%2F12%2F10%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[啊实打实大]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的广度优先遍历（BFS）和深度优先遍历（DFS）]]></title>
    <url>%2F2017%2F12%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[对于下面这段html代码,要求打印出每个节点的标签名和类名：1234567891011&lt;div id=&apos;root&apos;&gt; &lt;span&gt;123 &lt;a href=&quot;#&quot;&gt; sdsd &lt;/a&gt; &lt;div&gt;sdsd&lt;a&gt;这是一个a标签&lt;/a&gt;&lt;/div&gt; &lt;/span&gt; &lt;span&gt;456 &lt;p&gt;这是一个p标签&lt;/p&gt; &lt;/span&gt; &lt;/div&gt; 深度优先遍历当使用深度优先遍历算法实现的时候结果一般为该算法先将当前结点的孩子全部遍历结束，在遍历同一级的节点如图所示：先将2节点下的子节点遍历完，如果3号，4号 有子节点则再继续遍历该节点下的子节点，否则将遍历2节点的兄弟节点，直到遍历结束 下面给出该算法的js实现： （1）这是深度优先算法的递归实现123456789101112function deepTraversal(node,nodeList) &#123; if (node) &#123; nodeList.push(node); var children = node.children; for (var i = 0; i &lt; children.length; i++) //每次递归的时候将 需要遍历的节点 和 节点所存储的数组传下去 deepTraversal(children[i],nodeList); &#125; return nodeList; &#125; var root = document.getElementById(&apos;root&apos;)console.log(deepTraversal(root,nodeList=[])) （2）这是深度优先算法的递归实现1234567891011121314151617function deepTraversal(node) &#123; var nodeList = []; if (node) &#123; var stack = []; stack.push(node); while (stack.length != 0) &#123; var childrenItem = stack.pop(); nodeList.push(childrenItem); var childrenList = childrenItem.children; for (var i = childrenList.length - 1; i &gt;= 0; i--) stack.push(childrenList[i]); &#125; &#125; return nodeList; &#125; var root = document.getElementById(&apos;root&apos;)console.log(deepTraversal(root)) 广度优先遍历当使用广度优先遍历的时候，先依次遍历兄弟节点，然后便利兄弟节点下的子节点结果一般为：广度优先遍历二叉树，也就是按层次的去遍历。依次遍历根节点，然后是左孩子和右孩子。所以要遍历完当前节点的所有孩子，。根据左右孩子的顺序来输出，所以就是先进先出的原则，那么我们当然就想到了队列这个数据结构： （1） 广度优先算法的的非递归实现1234567891011121314151617function wideTraversal(node) &#123; var nodes = []; if (node != null) &#123; var queue = []; queue.unshift(node); while (queue.length != 0) &#123; var item = queue.shift(); nodes.push(item); var children = item.children; for (var i = 0; i &lt; children.length; i++) queue.push(children[i]); &#125; &#125; return nodes; &#125;var root = document.getElementById(&apos;root&apos;);console.log(wideTraversal(root)); （2）广度优先遍历的递归实现 以后再补]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
